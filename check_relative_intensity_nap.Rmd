# checking relative NAP and intensity

```{r load_data}
library(smirfeTools)
library(SIRM.FTMS.peakCharacterization)
library(dplyr)
library(tidyr)
library(ggplot2)

extracted_data <- readRDS("lung_matched_tissue_mz_testing.rds")
assignments <- readRDS("lung_matched_tissue_mz_testing_assingments.rds")

n_assignments <- apply(extracted_data$height, 2, function(x){sum(!is.na(x))})

use_data <- which.max(n_assignments)

df_data <- data.frame(mz = extracted_data$mz[, use_data],
                      height = extracted_data$height[, use_data])
df_data$imf <- extracted_data$imf[, use_data]
df_data$emf <- extracted_data$emf[, use_data]
df_data$peak = rownames(extracted_data$mz)
```

Now we need to do some fun calculations for all of the IMFs within an EMF.

We will calculate a relative fraction for each x-y pair of peaks within an EMF.

$$I_{ratio,x,y}=\frac{{I_{x} * NAP_{y}}}{I_y*NAP_x}$$


This $I_{ratio,x,y}$ can then be examined *wrt* M/Z to see how it tracks.

```{r assignment_info}
use_sample <- colnames(extracted_data$mz)[use_data]
assignment_info <- filter(assignments, sample %in% use_sample)

emf_data <- split(assignment_info, assignment_info$EMF)

calc_paired_ratios <- function(emf_info){
  peak_combinations <- expand.grid(emf_info$peak_id, emf_info$peak_id)
  peak_combinations <- peak_combinations[peak_combinations$Var2 > peak_combinations$Var1, ]
  
  paired_ratio <- purrr::map_df(seq(1, nrow(peak_combinations)), function(in_row){
    p1 <- which(emf_info$peak_id %in% peak_combinations[in_row, "Var1"])
    p2 <- which(emf_info$peak_id %in% peak_combinations[in_row, "Var2"])
    
    data.frame(mz = mean(emf_info[c(p1, p2), "ObservedMZ.Mean"]),
               xyratio = log10((emf_info[p1, "Height.Mean"] * emf_info[p2, "NAP"]) / (emf_info[p2, "Height.Mean"] * emf_info[p1, "NAP"])),
               mz_diff = abs(emf_info[p1, "ObservedMZ.Mean"] - emf_info[p2, "ObservedMZ.Mean"]))
  })
  paired_ratio$ratio_2_mz <- paired_ratio$xyratio / paired_ratio$mz_diff
  paired_ratio
}

emf_ratios <- purrr::map_df(emf_data, calc_paired_ratios)

ggplot(emf_ratios, aes(x = mz, y = (xyratio) / mz_diff)) + geom_point() + geom_smooth(method = "loess", span = 1.5) + ylim(-.5, .5)
```

And we see a relationship of this ratio with M/Z.

```{r do_it_for_all}
split_samples <- split(assignments, assignments$sample)

sample_ratios <- purrr::map(split_samples, function(in_sample){
  split_emf <- split(in_sample, in_sample$EMF)
  out_ratios <- purrr::map_df(split_emf, calc_paired_ratios)
  out_ratios <- out_ratios[(out_ratios$ratio_2_mz < 1) & (out_ratios$ratio_2_mz > -1), ]
})
```

```{r plot_them, fig.keep='all'}
set.seed(1234)
use_samples <- sample(length(sample_ratios), 20)

for (isample in use_samples) {
  p <- ggplot(sample_ratios[[isample]], aes(x = mz, y = ratio_2_mz)) + geom_point() + geom_smooth(method = "loess", span = 1.5) +
    labs(x = "M/Z", y = expression(log10(I[ratio_xy] / MZdiff[xy])))
  print(p)
}
```

```{r model_them}
all_models <- purrr::map2_dfr(sample_ratios, names(sample_ratios), function(in_ratio, id){
  loess_model <- loess(ratio_2_mz ~ mz, data = in_ratio, span = 1.5)
  loess_df <- loess_to_df(loess_model)
  loess_df$sample <- id
  filter(loess_df, which %in% "fitted")
})

use_samples_id <- names(sample_ratios)[use_samples]

ggplot(filter(all_models, sample %in% use_samples_id), aes(x = x, y = y, color = sample)) + geom_line() + theme(legend.position = "none") +
  labs(x = "M/Z", y = expression(log10(I[rel] / NAP)))
```

I should clean this data up a bit, and do IMF selection on each peak, and then only use those peaks that have a single IMF, TBH.

## Peak Number of Points by M/Z

Now lets examine the number of points in the peaks, and plot them by M/Z. The single scan one includes the noise peaks.

```{r raw_data}
zip_data <- zip_ms("~/Documents/manuscripts/peakCharacterization/data_analysis/data_input/100Cpos.zip")

zip_data$load_peak_finder()
zip_data$cleanup()


peak_1_scan <- zip_data$peak_finder$multi_scan_peaklist$peak_list_by_scans[[1]]$peak_list

ggplot(peak_1_scan, aes(x = ObservedMZ, y = n_point)) + geom_point() + geom_jitter()

peak_1_points <- transmute(peak_1_scan, npoint = n_point, mz = ObservedMZ)

average_peak_size <- function(mz_npoint, use_range = NULL, 
                              window = 1, delta = 0.1){
  if (is.null(use_range)) {
    use_range <- range(mz_npoint$mz)
  }

  window_locs <- data.frame(beg = round(seq(use_range[1], use_range[2] - window, delta), 2),
                            end = round(seq(use_range[1] + window, use_range[2], delta), 2))

  average_data <- purrr::map_df(seq(1, nrow(window_locs)), function(in_window){
    in_window <- (mz_npoint$mz >= window_locs[in_window, "beg"]) & (mz_npoint$mz <= window_locs[in_window, "end"])
    data.frame(density = sum(in_window),
               npoint = mean(mz_npoint[in_window, "npoint"]),
               mz = mean(mz_npoint[in_window, "mz"]))
  })
   average_data
}

all_scans_peaks <- purrr::map(zip_data$peak_finder$multi_scan_peaklist$peak_list_by_scans, function(x){
  tmp_list <- x$peak_list
  split_noise <- split(tmp_list, tmp_list$not_noise)
  names(split_noise) <- c("noise", "not_noise")
  split_noise <- purrr::map(split_noise, function(y){
    transmute(y, npoint = n_point, mz = ObservedMZ)
  })
  
  split_noise
})

all_scans_noise <- purrr::map_df(all_scans_peaks, "noise")

all_scans_not_noise <- purrr::map_df(all_scans_peaks, "not_noise")

# for a single scan
all_scans_noise_average_size <- average_peak_size(all_scans_noise, window = 100, delta = 1)
ggplot(all_scans_noise_average_size, aes(x = mz, y = npoint)) + geom_point() +
  labs(title = "all scans smushed noise size")

all_scans_not_noise_average_size <- average_peak_size(all_scans_not_noise, window = 100, delta = 1)
ggplot(all_scans_not_noise_average_size, aes(x = mz, y = npoint)) + geom_point() + 
  labs(title = "all scans smushed not noise size")

# grab the point data for the correspondent peaks
scan_order <- zip_data$peak_finder$correspondent_peaks$master_peak_list$scan_indices
zip_data$peak_finder$multi_scan_peaklist$scan_indices <- scan_order
all_peaklists <- purrr::map(zip_data$peak_finder$multi_scan_peaklist$get_scan_peak_lists(), "peak_list")
peaks <- zip_data$peak_finder$correspondent_peaks$master_peak_list$scan_peak

n_point_matrix <- matrix(NA, nrow = nrow(peaks), ncol = ncol(peaks))
for (icol in seq(1, ncol(peaks))) {
  tmp_list <- all_peaklists[[icol]]
  for (irow in seq(1, nrow(peaks))) {
    peak_index <- peaks[irow, icol]
    
    if (!is.na(peak_index)) {
      n_point_matrix[irow, icol] <- tmp_list[tmp_list$peak %in% peak_index, "n_point"]
      #print(c(peak_index, n_point_matrix[irow, icol]))
    }
      
  }
  
}

mean_point_matrix <- rowMeans(n_point_matrix, na.rm = TRUE)

mean_n_point_mz <- data.frame(mz = zip_data$peak_finder$correspondent_peaks$master_peak_list$master, npoint = mean_point_matrix,
                              nscan = rowSums(!is.na(n_point_matrix), na.rm = TRUE))

mean_n_point_mz <- filter(mean_n_point_mz, nscan >= 3)

p <- ggplot(mean_n_point_mz, aes(x = mz, y = npoint, color = nscan)) + geom_point() + labs(title = "correspondent peaks average n_point (no noise)")

all_average_points <- average_peak_size(mean_n_point_mz, window = 100, delta = 1)

p <- ggplot(all_average_points, aes(x = mz, y = npoint)) + geom_point() + geom_smooth(method = "loess", span = 1.5)
p + labs(title = "correspondent peaks average n_point smoothed")

mz_model <- loess_to_df(zip_data$peak_finder$multi_scan_peaklist$mz_model) %>% filter(which %in% "fitted")
mz_model$y2 <- max(mz_model$y) - mz_model$y

p + geom_point(data = mz_model, aes(x = x, y = (y2*1000) + 9), color = "red") + labs(title = "correspondent peaks average n_point smoothed + inverse of M/Z model")
```

So what if we scale this by the spacing in M/Z space? 

```{r scale_by_mz_model}
all_average_points$diff <- predict(zip_data$peak_finder$multi_scan_peaklist$mz_model, newdata = all_average_points$mz)

ggplot(all_average_points, aes(x = mz, y = npoint / (max(npoint)))) + geom_point()
```

Nope, doesn't really help us.