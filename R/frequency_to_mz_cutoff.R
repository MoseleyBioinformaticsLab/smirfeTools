#' get M/Z after Frequency
#'
#' The Frequency based cutoffs should be the most reliable **within** a set of
#' samples. However, they do not translate well across sample sets. Therefore,
#' a method is to split up the samples, run EMF voting using the derived frequency cutoff,
#' and then fit a generalized additive model to their M/Z standard deviations for
#' each IMF.
#'
#' @param assigned_set a set of samples defined by their common frequency conversion
#' @param freq_cutoff the cutoff used to exclude peaks in frequency space
#' @param set_id an optional identifier to identify which set of IMFs we have
#'
#' @export
#' @return data.frame of Index (M/Z) and Value (SD) and *set* (if set_id is supplied)
get_mz_after_freq = function(assigned_set, freq_cutoff, set_id = NULL){
  message("Running next set ...")
  extracts = extract_assigned_data(assigned_set, difference_cutoff = freq_cutoff,
                                   difference_measure = "ObservedFrequency",
                                   progress = FALSE)

  imf_mz = extract_imf_emf_data(extracts, Height, ObservedMZ, by = "IMF", scanlevel = TRUE)

  scan_mz = purrr::map_df(imf_mz$scanlevel_location, function(.x){
    data.frame(Index = mean(.x, na.rm = TRUE), Value = sd(.x, na.rm = TRUE),
               stringsAsFactors = FALSE)
  })

  if (!is.null(set_id)) {
    scan_mz$set = set_id
  }
  scan_mz
}

#' mz after frequency by group
#'
#' Given groups of samples in a list, run each one independently using frequency
#' cutoffs to calculate M/Z cutoffs
#'
#' @param grouped_samples the split sample assigned_data
#' @param freq_cutoff the frequency cutoff to use
#'
#' @export
#' @return data.frame with Index, Value, and set
grouped_mz_after_freq = function(grouped_samples, freq_cutoff){
  purrr::imap_dfr(grouped_samples, function(.x, .y){
    get_mz_after_freq(.x, freq_cutoff, .y)
  })
}

#' fit / predict M/Z
#'
#' Given a M/Z SD's generated by `get_mz_after_freq`, fit a model, create smaller data,
#' and predict values for M/Z based EMF voting.
#'
#' @param mz_sd data.frame of Value and Index
#' @param multiplier what multiplier of the base fit should be used? (default = 2)
#' @param step_size the increment to use going from low to high values of M/Z
#'
#' @export
#' @return data.frame of Index and Value
#'
fit_predict_mz_cutoff = function(mz_sd, multiplier = 2, step_size = 0.5){
  fit_mz = mgcv::gam(Value ~ s(Index, bs = "cs"), data = mz_sd)

  use_cutoff = data.frame(Index = seq(floor(min(mz_sd$Index)),
                                      ceiling(max(mz_sd$Index)),
                                      step_size))
  use_cutoff$Value = predict(fit_mz, use_cutoff) * multiplier
  use_cutoff
}

#' calculate mode
#'
#' Calculates the mode of a set of values
#'
#' @param values the values you want the first primary mode of
#'
#' @export
#' @return numeric
calculate_mode = function(values){
  density_estimate = stats::density(values)
  mode_value = density_estimate$x[which.max(density_estimate$y)]
  mode_value
}

#' sd by group
#'
#' Assuming you have some criteria by which you have split samples into a list,
#' and now you want to calculate the IMF frequency SD for each one independently.
#'
#' @param grouped_samples list of `assigned_data`
#' @param ... parameters for `find_confident_frequency_sd`
#'
#' @export
#' @return data.frame
sd_by_group = function(grouped_samples, ...){
  purrr::imap_dfr(grouped_samples, function(in_group, group_id){
    message("Running next set ...")
    tmp_sd = find_confident_frequency_sd(in_group, ...)
    tmp_sd$group = group_id
    tmp_sd
  })
}
